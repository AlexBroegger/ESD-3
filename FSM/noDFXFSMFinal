library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity top is
    Port (
        clk        : in  STD_LOGIC;             -- 12 MHz system clock
        rst        : in  STD_LOGIC;             -- active-high reset

        -- FAST DETECTION PINS (used for protocol detection)
        I2C_ENA    : in  STD_LOGIC;
        SPI_CS_IN  : in  STD_LOGIC;
        UART_RX_IN : in  STD_LOGIC;

        -- Pin configuration: 00 = hi-Z, 01 = I2C, 10 = SPI, 11 = UART
        MUX_SELECT : buffer STD_LOGIC_VECTOR(1 downto 0);

        -- Universal pins (shared physical pins)
        U_Pin_1 : inout STD_LOGIC;  -- SCL / SCLK / UART TX
        U_Pin_2 : inout STD_LOGIC;  -- SDA / MISO
        U_Pin_3 : inout STD_LOGIC;  -- MOSI

        -- Debug output
        DEBUG_OUT : out STD_LOGIC_VECTOR(7 downto 0)
    );
end top;

architecture Behavioral of top is

    ----------------------------------------------------------------------------
    -- Components
    ----------------------------------------------------------------------------
    component SPI_slave
        Port (
            SCLK: in  std_logic;
            MOSI: in  std_logic;
            MISO: out std_logic;
            CS  : in  std_logic
        );
    end component;

    component RX
        Port (
            clk          : in  std_logic;
            reset        : in  std_logic;
            rx_line      : in  std_logic;
            rx_data      : out STD_LOGIC_VECTOR(7 downto 0);
            rx_ready     : out std_logic;
            parity_enable: in  std_logic;
            parity_m     : in  std_logic;
            parity_valid : out std_logic
        );
    end component;

    component i2c_Master
        Port (
            clk       : in std_logic;
            reset     : in std_logic;
            ena       : in std_logic;
            rw        : in std_logic;
            s_addr    : in std_logic_vector(6 downto 0);
            write_in  : in std_logic_vector(7 downto 0);
            new_input : out std_logic;
            read_out  : out std_logic_vector(7 downto 0);
            busy      : out std_logic;
            ack_error : out std_logic;
            sda       : inout std_logic;
            scl       : inout std_logic
        );
    end component;

    ----------------------------------------------------------------------------
    -- Internal signals
    ----------------------------------------------------------------------------
    -- SPI
    signal spi_sclk_int, spi_mosi_int : std_logic := '0';
    signal spi_miso_int, spi_cs_int   : std_logic := 'Z';

    -- UART
    signal uart_tx_int  : std_logic := 'Z';
    signal uart_data    : std_logic_vector(7 downto 0) := (others => '0');
    signal uart_ready   : std_logic := '0';
    signal uart_rx_int  : std_logic := '1';

    -- I2C
    signal i2c_scl_int, i2c_sda_int : std_logic := 'Z';
    signal i2c_ena_int : std_logic := '0';
    signal i2c_rw      : std_logic := '0';
    signal i2c_addr    : std_logic_vector(6 downto 0) := (others => '0');
    signal i2c_data_in, i2c_data_out : std_logic_vector(7 downto 0) := (others => '0');
    signal i2c_busy_sig, i2c_ack_err_sig, i2c_new_input : std_logic := '0';

    -- FSM
    type fsm_state_type is (IDLE_MONITOR, ACTIVE_I2C, ACTIVE_SPI, ACTIVE_UART);
    signal state_reg, state_next : fsm_state_type := IDLE_MONITOR;

    -- Universal pin drivers
    signal u1_out, u2_out, u3_out : std_logic := 'Z';
    signal u1_oe, u2_oe, u3_oe    : std_logic := '0';
    signal u1_in, u2_in, u3_in    : std_logic;

    -- Debug register
    signal debug_reg : std_logic_vector(7 downto 0) := (others => '0');

    -- ACTIVIY DETECTION
    signal I2C_ACTIVITY_DETECTED : STD_LOGIC := '0';
    signal SPI_ACTIVITY_DETECTED : STD_LOGIC := '0';
    signal UART_ACTIVITY_DETECTED : STD_LOGIC := '0';

    signal i2c_sda_prev : STD_LOGIC := '1'; 
    signal spi_cs_prev  : STD_LOGIC := '1';
    signal uart_rx_prev : STD_LOGIC := '1';

begin

    spi_cs_int <= SPI_CS_IN;
    uart_rx_int <= UART_RX_IN;
    i2c_ena_int <= I2C_ENA;

    ----------------------------------------------------------------------------
    -- Map tri-state drivers to physical pins
    ----------------------------------------------------------------------------
    U_Pin_1 <= u1_out when u1_oe = '1' else 'Z';
    U_Pin_2 <= u2_out when u2_oe = '1' else 'Z';
    U_Pin_3 <= u3_out when u3_oe = '1' else 'Z';

    -- Always sample inputs
    u1_in <= U_Pin_1;
    u2_in <= U_Pin_2;
    u3_in <= U_Pin_3;
    
    

    ----------------------------------------------------------------------------
    -- Simple detection logic (no synchronizers)
    ----------------------------------------------------------------------------
process(clk)
begin
    if rising_edge(clk) then

        -- Husk tidligere værdier
        spi_cs_prev  <= spi_cs_int;
        uart_rx_prev <= uart_rx_int;

        -- I2C detection via fast ENA pin
        if I2C_ENA = '1' then
            I2C_ACTIVITY_DETECTED <= '1';
        else
            I2C_ACTIVITY_DETECTED <= '0';
        end if;

        -- SPI detection (falling edge på CS)
        if spi_cs_int = '0' and spi_cs_prev = '1' then
            SPI_ACTIVITY_DETECTED <= '1';
        else
            SPI_ACTIVITY_DETECTED <= '0';
        end if;

        -- UART startbit detection
        if uart_rx_int = '0' and uart_rx_prev = '1' then
            UART_ACTIVITY_DETECTED <= '1';
        else
            UART_ACTIVITY_DETECTED <= '0';
        end if;

    end if;
end process;

--------------------------------------------------------------------------
-- NEXT STATE LOGIC
--------------------------------------------------------------------------
process(state_reg, I2C_ACTIVITY_DETECTED, SPI_ACTIVITY_DETECTED, UART_ACTIVITY_DETECTED)
begin
    state_next <= state_reg;

    case state_reg is
        
        when IDLE_MONITOR =>
            if I2C_ACTIVITY_DETECTED = '1' then
                state_next <= ACTIVE_I2C;
            elsif SPI_ACTIVITY_DETECTED = '1' then
                state_next <= ACTIVE_SPI;
            elsif UART_ACTIVITY_DETECTED = '1' then
                state_next <= ACTIVE_UART;
            end if;

        when ACTIVE_I2C  => state_next <= ACTIVE_I2C;
        when ACTIVE_SPI  => state_next <= ACTIVE_SPI;
        when ACTIVE_UART => state_next <= ACTIVE_UART;

        when others =>
            state_next <= IDLE_MONITOR;
    end case;

end process;

    ----------------------------------------------------------------------------
    -- FSM register
    ----------------------------------------------------------------------------
    process(clk, rst)
    begin
        if rst = '1' then
            state_reg <= IDLE_MONITOR;
        elsif rising_edge(clk) then
            state_reg <= state_next;
        end if;
    end process;

    ----------------------------------------------------------------------------
    -- Output logic for tri-state pins
    ----------------------------------------------------------------------------
    process(state_reg)
    begin
        -- defaults
        u1_out <= 'Z'; u1_oe <= '0';
        u2_out <= 'Z'; u2_oe <= '0';
        u3_out <= 'Z'; u3_oe <= '0';

        -- internal signals default
        spi_sclk_int <= u1_in;
        spi_mosi_int <= u3_in;
        uart_tx_int  <= 'Z';
        i2c_scl_int  <= 'Z';
        i2c_sda_int  <= 'Z';
        i2c_ena_int  <= '0';

        MUX_SELECT <= "00";

    case state_reg is

        when IDLE_MONITOR =>
            MUX_SELECT <= "00";

        when ACTIVE_I2C =>
            MUX_SELECT <= "01";

        when ACTIVE_SPI =>
            MUX_SELECT <= "10";

        when ACTIVE_UART =>
            MUX_SELECT <= "11";

        when others =>
            MUX_SELECT <= "00";
    end case;


    end process;



process(MUX_SELECT, i2c_scl_int, i2c_sda_int,
        spi_sclk_int, spi_miso_int, uart_tx_int)

begin
    -- Universal Pin MUX
        case MUX_SELECT is
        
            -- I2C
            when "01" =>
                if i2c_scl_int = '0' then u1_out <= '0'; u1_oe <= '1'; end if;
                if i2c_sda_int = '0' then u2_out <= '0'; u2_oe <= '1'; end if;

            -- SPI
            when "10" =>
                u2_out <= spi_miso_int; u2_oe <= '1';

            -- UART
            when "11" =>
                u2_out <= uart_tx_int; u2_oe <= '1';

            when others =>
                null;
        end case;

end process;

    ----------------------------------------------------------------------------
    -- Debug capture
    ----------------------------------------------------------------------------
    process(clk, rst)
    begin
        if rst = '1' then
            debug_reg <= (others => '0');
        elsif rising_edge(clk) then
            if state_reg = ACTIVE_UART and uart_ready = '1' then
                debug_reg <= uart_data;
            elsif state_reg = ACTIVE_SPI then
                -- you can connect to SPI byte monitor
                null;
            elsif state_reg = ACTIVE_I2C and i2c_busy_sig = '0' then
                debug_reg <= i2c_data_out;
            end if;
        end if;
    end process;

    DEBUG_OUT <= debug_reg;

    ----------------------------------------------------------------------------
    -- Protocol instances
    ----------------------------------------------------------------------------
    SPI_slave_inst : SPI_slave
        Port Map (
            SCLK => spi_sclk_int,
            MOSI => spi_mosi_int,
            MISO => spi_miso_int,
            CS   => spi_cs_int
        );

    UART_inst : RX
        port map(
            clk => clk,
            reset => rst,
            rx_line => uart_rx_int,
            rx_data => uart_data,
            rx_ready => uart_ready,
            parity_enable => '0',
            parity_m => '0',
            parity_valid => open
        );

    I2C_master_inst : I2C_Master
        Port Map(
            clk => clk,
            reset => rst,
            ena => i2c_ena_int,
            rw  => i2c_rw,
            s_addr => i2c_addr,
            write_in => i2c_data_in,
            new_input => i2c_new_input,
            read_out => i2c_data_out,
            busy => i2c_busy_sig,
            ack_error => i2c_ack_err_sig,
            sda => i2c_sda_int,
            scl => i2c_scl_int
        );

end Behavioral;
