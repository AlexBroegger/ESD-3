library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity RX is
    port (
        clk        : in  std_logic;
        reset      : in  std_logic;
        rx_line    : in  std_logic;
        rx_data    : out unsigned(7 downto 0);
        rx_ready   : out std_logic
    );
end RX;

architecture rtl of RX is

    type Rstate is (IDLE, START, DATA, STOP);
    signal state, next_state : Rstate;

    signal rx_sync_1, rx_sync_2 : std_logic;

    signal shift_reg : unsigned(7 downto 0);
    signal bit_count : integer range 0 to 7;

    -- Oversampling 16x
    constant oversample  : integer := 16;
    constant clock_p_16x : integer := 78;   -- 12MHz / (9600 * 16)
    signal os_count      : integer range 0 to clock_p_16x-1;
    signal os_tick       : std_logic;

    signal sample_count  : integer range 0 to oversample-1;

    signal shift_en      : std_logic;
    signal done_sample   : std_logic;

begin

    -------------------------------------------------------------------
    -- 2-flip-flop synchronizer
    -------------------------------------------------------------------
    sync_proc : process(clk, reset)
    begin
        if reset='1' then
            rx_sync_1 <= '1';
            rx_sync_2 <= '1';
        elsif rising_edge(clk) then
            rx_sync_1 <= rx_line;
            rx_sync_2 <= rx_sync_1;
        end if;
    end process;

    -------------------------------------------------------------------
    -- Oversampling tick generator (16Ã— baud)
    -------------------------------------------------------------------
    os_baud : process(clk, reset)
    begin
        if reset='1' then
            os_count <= 0;
            os_tick  <= '0';
        elsif rising_edge(clk) then
            os_tick <= '0';
            if os_count = clock_p_16x-1 then
                os_count <= 0;
                os_tick  <= '1';
            else
                os_count <= os_count + 1;
            end if;
        end if;
    end process;

    -------------------------------------------------------------------
    -- State + data path
    -------------------------------------------------------------------
    reg_proc : process(clk, reset)
    begin
        if reset='1' then
            state        <= IDLE;
            shift_reg    <= (others=>'0');
            bit_count    <= 0;
            sample_count <= 0;
            rx_data      <= (others=>'0');

        elsif rising_edge(clk) then
            state <= next_state;

            if state = IDLE then
                sample_count <= 0;
                bit_count    <= 0;

            elsif os_tick='1' then

                -- sample counter (0-15)
                if sample_count = oversample-1 then
                    sample_count <= 0;
                else
                    sample_count <= sample_count + 1;
                end if;

                -- shift bits into register
                if shift_en='1' then
                    shift_reg <= rx_sync_2 & shift_reg(7 downto 1);
                    bit_count <= bit_count + 1;
                end if;

                -- latch output byte
                if done_sample='1' then
                    rx_data <= shift_reg;
                end if;
            end if;
        end if;
    end process;

    -------------------------------------------------------------------
    -- Next-state logic
    -------------------------------------------------------------------
    next_state_proc : process(state, rx_sync_2, bit_count, sample_count, os_tick)
    begin
        next_state <= state;

        case state is
            when IDLE =>
                if rx_sync_2 = '0' then
                    next_state <= START;
                end if;

            when START =>
                if os_tick='1' and sample_count = oversample/2 then
                    if rx_sync_2='0' then
                        next_state <= DATA;
                    else
                        next_state <= IDLE;
                    end if;
                end if;

            when DATA =>
                if os_tick='1' and sample_count = oversample/2 then
                    if bit_count = 7 then
                        next_state <= STOP;
                    end if;
                end if;

            when STOP =>
                if os_tick='1' and sample_count = oversample/2 then
                    next_state <= IDLE;
                end if;
        end case;
    end process;

    -------------------------------------------------------------------
    -- Output control
    -------------------------------------------------------------------
    out_proc : process(state, sample_count, os_tick)
    begin
        rx_ready    <= '0';
        shift_en    <= '0';
        done_sample <= '0';

        case state is
            when IDLE =>
                null;

            when START =>
                null;

            when DATA =>
                if os_tick='1' and sample_count = oversample/2 then
                    shift_en <= '1';
                end if;

            when STOP =>
                if os_tick='1' and sample_count = oversample/2 then
                    rx_ready    <= '1';
                    done_sample <= '1';
                end if;
        end case;
    end process;

end rtl;
